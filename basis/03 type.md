# 类型

## 转换

- C#里，互相兼容的类型实例间可以相互转换。
- 转换总是从现有的值创建出来一个新的值。
- 隐式 or 显式
  - 隐式转换是自动发生的
  - 显式转换需要手动进行

```c#
int x = 12345;
long y = x;         // 隐式转换 int类型的范围小于long类型的范围
short z = (short)y; // 显式转换
```

### 隐式 vs 显式转换

隐式转换的两个必要条件：

- 编译器可以保证转换会成功
- 信息不会有损失

显式转换的条件**（任意一个成立）**：

- 编译器不能保证转换会成功
- 信息可能会有损失

<font color="crimson">如果编译器可以断定转换肯定会失败，那么两种转换都会被禁止。</font>

## 值类型 VS 引用类型

### 所有类型

- 值类型
- 引用类型
- 范型类型参数
- 指针类型

### 二者对比

- 值类型包含所有的内置类型（数值、字符、`bool`）和自定义的`struct`和`enum`
- 引用类型包含所有的`class`，数组，`delegate`，`interface`类型。包括字符串。
- 它们的根本区别在于处理内存的方式。
  - - 值类型变量/常量的内容就是一个值。
    - 使用struct关键字可以创建自定义的值类型。
    - 值类型实例的赋值动作总是**复制了该实例**。
  - 引用类型
    - 分为两部分：对象 + 到该对象的引用
    - 引用类型的变量/常量的内容就是到一个含有值的对象的引用。
    - 给引用类型的变量赋值：**复制引用**，而不是对象实例。
    - 允许多个变量引用同一个对象。（值类型就没这种可能）

### Null

- `Null`是一个literal。
- 可以把`null`赋值给引用，表示该引用不指向任何一个对象。
- `null.Property` 会抛出 `NullReferenceException`
- **普通的值类型不可以为`null`。**
- C#有一种可空类型（nullable types）来表示值类型的`null`。

### 存储的开销

- 值类型
  - 值类型的实例所占的内存 = 它的字段需要内存的总和
  - CLR会把类型内的字段大小设置为该字段实际大小的整数倍。
- 引用类型
  - 需要为 引用 和 对象 单独分配内存。
  - 对象所占内存 = 其字段所占内存总和 + 额外的管理开销（最少8字节）
  - 每个对象的引用还需要额外的4或8个字节，（根据平台是32位还是64位）

### 内置类型的分类

- 值类型
  - 数值型
    - Signed integer（`sbyte`，`short`，`int`，`long`）
    - Unsigned integer（`byte`，`ushort`，`uint`，`ulong`）
    - 实数（`float`，`double`，`decimal`）
  - 逻辑（`bool`）
  - 字符（`char`）
- 引用类型
  - 字符串（`string`）
  - 对象（`object`）
- System命名空间
- 除了`decimal`之外的内置类型叫做原始类型
  - 通过指令，在编译的代码里直接被支持，通常被翻译成底层处理器直接的支持
- `System.IntPtr` 和 `System.UIntPtr` 也是原始类型。
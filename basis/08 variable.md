# 变量

一个变量代表一个存储的位置，它的值是可以改变的

变量可以是

- 本地的
- 参数（值类型、ref、out）
- 字段
- 数组的元素



## Stack 栈 vs Heap 堆

- Stack 和 Heap 是变量和常量的所在地
- 生命周期不同

### Stack 栈

- Stack（一块内存）存储**本地变量**和**参数**
- 随着函数的进入和退出，Stack也会随之增大和缩小

```c#
static int Factorial(int x)
{
    if(x == 0) return 1;
    return x * Factorial(x-1);
}
```

### Heap 堆

- Heap（一块内存），对象所在的地方（**引用类型的实例**）
- 当新的对象被创建后，它就会被分配在Heap上，到该对象的一个引用被返回。
- 程序执行时，随着新对象的不断建立，heap会被慢慢的填满。运行时的gc会周期性的把对象从heap上面释放出来，所以不会导致内存耗尽
- 一旦一个对象不再被任何“存活”的东西所引用，那么它就可以被释放了

### 内存

- 值类型的实例（和对象的引用）会放在变量声明时所在的内存块里。
- 如果该实例是一个class的字段或数组的元素，那么它就在Heap上

### GC

- C#里不可以显式的删除对象
- 无引用的对象会逐渐的被GC收集

### Static 字段

- 在Heap上
- 它们会存活到应用程序域停止

## 确定赋值 Definite Assignment

除非使用unsafe，否则在C#里无法访问未初始化的内存。

Definite Assignment的三个含义：

- 本地变量在被读取之前必须被赋值
- 当方法被调用的时候，函数的参数必须被提供（除非是可选参数）
- 其它的变量（字段、数组元素）会被运行时自动初始化

### 默认值

- 所有类型的实例都有默认值
- 预定义类型的默认值就是内存按位归零的结果

| Type                     | Default Value |
| ------------------------ | ------------- |
| All reference types      | null          |
| All numeric & enum types | 0             |
| char type                | '\0'          |
| bool type                | false         |

- 通过default关键字来获取任何类型的默认值
- 自定义值类型（struct）的默认值就是该自定义类型定义的每个字段的默认值

## 参数

一个方法可以多个参数（parameters），参数（parameters）定义了必须为该方法提供的参数（arguments）

### 参数传递的方式

| Parameter modifier | Passed by | Variable must be definitely assigned |
| ------------------ | --------- | ------------------------------------ |
| (None)             | Value     | Going in                             |
| ref                | Reference | Going in                             |
| out                | Reference | Going out                            |

- 默认情况下，按值传递arguments
- 当传进方法时把arguments的值复制了一份
- 复制的是引用，不是对象
- 想要按引用传递，可以使用ref 参数修饰符
- **无论是引用类型还是值类型的参数，都可以按值或按引用传递**

### 按引用传递 ref

想要按引用传递，可以使用ref 参数修饰符

### 按引用传递out

和ref差不多，除了：

- 进入函数前不需要被赋值
- 离开函数前必须被赋值

通常用来从方法返回多个值

#### out 变量

- 从C# 7 开始，调用方法时，可以使用out临时声明变量
- 当调用的方法有多个out参数时，你不需要其中一些out参数，可以使用下划线 “_” 来弃用它们。

### 按引用类型进行传递的含义

当你按引用传递arguments的时候，相当于给现有变量的存储位置起了个别名，而不是创建了一个新的存储位置

### params修饰符

- 可以在方法的最后一个参数使用params参数修饰符
- 可以接受任意数量的该类型的参数
- 参数（parameters）类型必须是数组
- 也可使用数组作为arguments

### 可选参数

- 从C# 4.0开始，方法、构造函数、索引器都可以声明可选参数
- 可选参数需要在声明的时候提供默认值
- Foo();  相当于 Foo(23); 编译器在调用方把23写死进去

```c#
void Foo (int x = 23)
{
    Console.WriteLine (x);
}
```

- 调用时可以不填写可选的parameters
- 往public方法里添加可选参数，若该方法被其它Assembly调用，那么两个Assemblies都需要重新编译，就和添加了一个必填参数是一样的
- 可选参数的默认值必须是常量表达式或拥有无参构造函数的值类型
- 可选参数不可以使用ref 和 out
- 必填参数必须在可选参数前面（方法声明时和方法调用时）。
- 例外是：params 的参数仍然放在最后边

### 命名参数

- 可以不按位置来区别arguments
- 使用名称来定位arguments
- 命名的arguments可以按任意顺序填写
- Arguments表达式被计算出的顺序和它们在调用地出现的顺序一致
- 可混合使用按位参数和命名参数
- 按位参数必须放在命名参数前
- 可混合使用可选参数和命名参数

### ref Locals

- C# 7，可以定义一个本地变量，它引用了数组的一个元素或对象的一个字段

```c#
int[] numbers = { 0, 1, 2, 3, 4 };
ref int numRef = ref numbers [2];
```

- numRef就是对numbers[2]的引用，修改numRef的时候，就是修改numbers[2]这个元素。
- Ref Local的目标必须是数组的元素，字段，本地变量。不可以是属性
- 常用于微优化场景，通常与 ref returns联合使用

可以从方法返回ref local，这就叫做ref return

## var

- 隐式强类型本地变量
- 声明和初始化变量通常一步完成，如果编译器能从初始化表达式推断出类型，就可以使用var
- 会降低代码的可读性





